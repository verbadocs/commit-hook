#!/usr/bin/env bash
set -euo pipefail

# Guard to avoid infinite loop on our own amend
if [[ "${GIT_VERBA_AMEND:-0}" == "1" ]]; then
  exit 0
fi

REPO_ROOT="$(git rev-parse --show-toplevel)"
cd "$REPO_ROOT"

PROMPT_HISTORY_DIR="$REPO_ROOT/verba/prompt_history"
DB_PATH="$REPO_ROOT/verba/changes.db"

# Current commit
CURRENT_COMMIT_HASH="$(git rev-parse HEAD)"

# Most recent JSON export (if any)
LATEST_JSON="$(ls -t "$PROMPT_HISTORY_DIR"/db-export-*.json 2>/dev/null | head -1 || true)"

# If we have a JSON export and Python, mark those records as committed in the DB
if [[ -n "${LATEST_JSON:-}" ]] && command -v python3 >/dev/null 2>&1; then
  python3 - <<PY
import json, sqlite3, sys
json_file = r'''$LATEST_JSON'''
commit_hash = r'''$CURRENT_COMMIT_HASH'''
try:
    with open(json_file, 'r', encoding='utf-8') as f:
        export_data = json.load(f)
    records = export_data.get('records') or []
    change_hashes = [r.get('change_hash') for r in records if r.get('change_hash')]
    if not change_hashes:
        sys.exit(0)
    conn = sqlite3.connect(r'''$DB_PATH''')
    cur = conn.cursor()
    ph = ','.join('?' for _ in change_hashes)
    sql = f'UPDATE code_changes SET is_committed = 1, commit_hash = ? WHERE change_hash IN ({ph})'
    cur.execute(sql, [commit_hash] + change_hashes)
    conn.commit()
    conn.close()
except Exception as e:
    print(f'Error updating database: {e}', file=sys.stderr)
    sys.exit(1)
PY
fi

# If the DB changed after the commit, fold it into the same commit with an amend.
# `git diff -- verba/changes.db` compares working tree vs index.
if ! git diff --quiet -- verba/changes.db; then
  git add -f verba/changes.db
  # Prevent re-entry on the amend's post-commit
  GIT_VERBA_AMEND=1 git commit --amend --no-edit >/dev/null 2>&1 || true
fi
